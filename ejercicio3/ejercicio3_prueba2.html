<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Triangle Application</title>
</head>

<body onload="init()">
    <canvas id="myCanvas" width="640" height="480" style="border: 1px solid black;"></canvas>

    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec4 a_Position;
        void main() {
            gl_Position = a_Position;
            gl_PointSize = 5.0;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec4 u_FragColor;
        void main() {
            gl_FragColor = u_FragColor;
        }
    </script>

    <script>
        var canvas, gl;
        var points = [];
        var colorIndex = 0;
        var colors = [
            [1.0, 0.0, 0.0, 1.0], // Red
            [0.0, 1.0, 0.0, 1.0], // Green
            [0.0, 0.0, 1.0, 1.0]  // Blue
        ];

        function init() {
            // Get canvas object from the DOM
            var canvas = document.getElementById("myCanvas");

            // Get the rendering context for WebGL
            var gl = canvas.getContext("webgl");
            if (!gl) {
                console.log("Failed to get the rendering context for WebGL");
                return;
            }

            // Set clear color
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            // Clear canvas
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Register event handler
            canvas.onmousedown = function (ev) {
                click(ev, gl, canvas);
            };
        }

        function click(ev, gl, canvas) {
            // Coordinates of canvas origin
            var rect = ev.target.getBoundingClientRect();

            // relative x coordinate of click in canvas
            var clickX = ev.clientX - rect.left;

            // relative y coordinate of click in canvas
            var clickY = ev.clientY - rect.top;

            // WebGL coordinates (3D)
            var halfCanvasWidth = canvas.width / 2;
            var halfCanvasHeight = canvas.height / 2;

            var x = (clickX - halfCanvasWidth) / halfCanvasWidth;
            var y = (halfCanvasHeight - clickY) / halfCanvasHeight;

            var point = [x, y, 0];

            // Draw a point
            drawPoint(gl, point);

            // Draw triangle if there are at least 3 points
            if (points.length >= 3) {
                // Draw triangles with the last two points and the new point
                drawTriangle(gl, [points[points.length - 3], points[points.length - 2], point]);
            }
        }


        function drawPoint(gl, point) {
            var vertexShader = document.getElementById("vertexShader").innerHTML;
            var fragmentShader = document.getElementById("fragmentShader").innerHTML;

            // Initialize shaders
            if (!initShaders(gl, vertexShader, fragmentShader)) {
                console.log("Failed to initialize shaders");
                return;
            }

            // Create buffer and set vertex data
            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(point), gl.STATIC_DRAW);

            // Get attribute location
            var a_Position = gl.getAttribLocation(gl.program, 'a_Position');

            // Assign buffer to attribute variable
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);

            // Enable attribute variable
            gl.enableVertexAttribArray(a_Position);

            // Set the color of the point
            var u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor');
            gl.uniform4fv(u_FragColor, colors[colorIndex]);

            // Draw the point
            gl.drawArrays(gl.POINTS, 0, 1);

            // Increment color index for the next point
            colorIndex = (colorIndex + 1) % colors.length;

            // Add the point to the array
            points.push(point);
        }

        function drawTriangle(gl, vertices) {
            // Use the same shaders for simplicity
            var vertexShader = document.getElementById("vertexShader").innerHTML;
            var fragmentShader = document.getElementById("fragmentShader").innerHTML;

            // Initialize shaders
            if (!initShaders(gl, vertexShader, fragmentShader)) {
                console.log("Failed to initialize shaders");
                return;
            }

            // Create buffer and set vertex data
            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices.flat()), gl.STATIC_DRAW);

            // Get attribute location
            var a_Position = gl.getAttribLocation(gl.program, 'a_Position');

            // Assign buffer to attribute variable
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);

            // Enable attribute variable
            gl.enableVertexAttribArray(a_Position);

            // Set the color of the triangle
            var u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor');
            gl.uniform4fv(u_FragColor, colors[colorIndex]);

            // Draw the triangle
            gl.drawArrays(gl.TRIANGLES, 0, 3);

            // Increment color index for the next triangle
            colorIndex = (colorIndex + 1) % colors.length;

            // Clear the points array for the next triangle
            points = [];
        }


        function initShaders(gl, vertexShaderSource, fragmentShaderSource) {
            // Compile vertex shader
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
                return false;
            }

            // Compile fragment shader
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
                return false;
            }

            // Create shader program
            gl.program = gl.createProgram();
            gl.attachShader(gl.program, vertexShader);
            gl.attachShader(gl.program, fragmentShader);
            gl.linkProgram(gl.program);
            if (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) {
                console.error('ERROR linking program!', gl.getProgramInfoLog(gl.program));
                return false;
            }

            // Use the program
            gl.useProgram(gl.program);

            return true;
        }
        
    </script>
</body>

</html>